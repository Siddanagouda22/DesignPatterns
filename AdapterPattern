/// <summary>
/// The Adapter is a class that’s able to work with both the client and the service:
/// it implements the client interface, while wrapping the service object.
/// The adapter receives calls from the client via the adapter interface and translates them
/// into calls to the wrapped service object in a format it can understand.
/// </summary>

public interface IDuck
    {
        void Quack();
        void Fly();
    }
--=========================================
public interface ITurkey
    {
        void Gobble();
        void Fly();
    }
--=========================================
class MallardDuck : IDuck
    {
        public void Quack()
        {
            Console.WriteLine("Quack Quack Quack");
        }

        public void Fly()
        {
            Console.WriteLine("Flies 500 Metres");
        }
    }
--=================================================
 class WildTurkey : ITurkey
    {
        public void Gobble()
        {
            Console.WriteLine("Gobble Gobble Gobble");
        }

        public void Fly()
        {
            Console.WriteLine("Flies 100 Metres");
        }
    }
--=================================================
 public class TurkeyAdapter : IDuck
    {
        private readonly ITurkey _turkey;

        public TurkeyAdapter(ITurkey turkey)
        {
            _turkey = turkey;
        }
        public void Quack()
        {
            _turkey.Gobble();
        }

        public void Fly()
        {
            for (var i = 0; i < 5; i++)
            {
                _turkey.Fly();
                Console.WriteLine("Resting..");
            }
        }
    }
--========================================================
        private static void Main()
        {
            var turkey = new WildTurkey();
            var adapter = new TurkeyAdapter(turkey);

            Tester(adapter);
        }

        private static void Tester(IDuck duck)
        {
            duck.Fly();
            duck.Quack();
        }
--========================================================
--======================Second Example ==================================
public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Salary { get; set; }
}

/// <summary>
/// The Client Interface describes a protocol that other classes must follow to be able to collaborate with the client code.
/// </summary>
public interface ISalaryProcessor
{
    void ProcessSalaries(string[,] rawEmployees);
}

/// <summary>
/// The Service is some useful class (usually 3rd-party or legacy).
/// The client can’t use this class directly because it has an incompatible interface.
/// </summary>
public class ThirdPartyBillingSystem
{
    public void ProcessSalary(List<Employee> employees)
    {
        foreach (var employee in employees)
        {
            Console.WriteLine($"EUR {employee.Salary} salary credited to {employee.Name}'s account.");
        }
    }
}

/// <summary>
/// This class contains the functionality which the client requires,
/// but it's not compatible with the existing client code.
/// So, it requires some adaptation before the client code can use it.
/// </summary>
public class HRSystem
{
    public string[,] GetEmployeesInfo() =>
        new string[4, 3]
        {
            { "1", "John", "5950" },
            { "2", "Anna", "5800" },
            { "3", "Nicole", "6100" },
            { "4", "Steven", "5000" },
        };
}

/// <summary>
/// This is a class which makes two incompatible systems to work together.
/// The Adapter is a class that’s able to work with both the client and the service:
/// it implements the client interface, while wrapping the service object.
/// The adapter receives calls from the client via the adapter interface and translates them
/// into calls to the wrapped service object in a format it can understand.
/// </summary>
public class HRSystemAdapter : ISalaryProcessor
{
    private readonly ThirdPartyBillingSystem _thirdPartyBillingSystem;

    public HRSystemAdapter()
    {
        _thirdPartyBillingSystem = new ThirdPartyBillingSystem();
    }

    public void ProcessSalaries(string[,] rawEmployees)
    {
        var employeesForProcessing = PrepareEmployeesForSalaryProcessing(rawEmployees);
        _thirdPartyBillingSystem.ProcessSalary(employeesForProcessing);
    }

    private static List<Employee> PrepareEmployeesForSalaryProcessing(string[,] rawEmployees)
    {
        var employeesForProcessing = new List<Employee>();

        for (var i = 0; i < rawEmployees.GetLength(0); i++)
        {
            var id = string.Empty;
            var name = string.Empty;
            var salary = string.Empty;

            for (var j = 0; j < rawEmployees.GetLength(1); j++)
            {
                switch (j)
                {
                    case 0:
                        id = rawEmployees[i, j];
                        break;
                    case 1:
                        name = rawEmployees[i, j];
                        break;
                    default:
                        salary = rawEmployees[i, j];
                        break;
                }
            }

            var employee = new Employee
            {
                Id = Convert.ToInt32(id, CultureInfo.InvariantCulture),
                Name = name,
                Salary = Convert.ToDecimal(salary, CultureInfo.InvariantCulture),
            };
            employeesForProcessing.Add(employee);
        }

        Console.WriteLine("Adapter converted array of employees to list of employees...");

        return employeesForProcessing;
    }
}

